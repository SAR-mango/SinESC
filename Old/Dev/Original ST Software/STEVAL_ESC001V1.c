/**
  ******************************************************************************
  * @file    STEVAL_ESC001V1.c
  * @author  SRA - MC Team
  * @version 1.1.3
  * @date    28-Feb-2019 9:29
  * @brief   ESC001V1 Eval board      
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of thn
                            e License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/

#include "stm32f3xx_hal.h"
#include "stm32f3xx.h"
#include "mc_type.h"
#include "stdbool.h"
#include "parameters_conversion.h"
#include "mc_config.h"
#include "STEVAL_ESC001V1.h"
#include "main.h"

/************************** USER SETTINGS  ************************************/
#define FILTER_DEEP           4                        /*!<  Command PWM Low pass filter variable */
#define PWM_ESC                                        /*!<  If undef enables the WB tool (ESC function disables) */
//#define TELEMETRY_LOG                                  /*!<  If defined enables the telemetry communication throught serial COM port */
#define STOP_DURATION_SEC     2                        /*!<  Time (sec) for restart after fault */
#define TURNOFF_TIME_SEC      2                        /*!<  Time (sec) for disarming */
#define ARMING_TIME_SEC       2

uint32_t Ton_max_us =   1860;                          /*!<  Maximum Ton value for PWM in usec(by default is for 400Hz PWM) */
uint32_t Ton_min_us  =  1086;                          /*!<  Minimum Ton value for PWM in usec (by default is for 400Hz PWM) */
uint32_t Threshold_start_us = 10;                      /*!<  Threshold in usec for startup and turnoff hysteresis for turnon  (ESC start -> [Ton_min_us + Threshold_start_us])  */
uint32_t Threshold_stop_us  = 10;                      /*!<  Threshold in usec for startup and turnoff hysteresis for turnoff (ESC stop -> [Ton_min_us - Threshold_stop_us] )  */
uint16_t speed_max_valueRPM = MAX_APPLICATION_SPEED;   /*!<  Maximum value for speed reference (auto-generated by ST MC Workbench) */
uint16_t speed_min_valueRPM = 1000;                    /*!<  Set the minimum value for speed reference (manual edit) */

/**************************  FW VARIABLES AND DEFINE *************************************/
/* Define --------------------------------------------------------------------*/
#define COUNT_MAX_SEC   1    
#define COUNT_MAX (COUNT_MAX_SEC * SYS_TICK_FREQUENCY/4)
#define USER_TIMEBASE_FREQUENCY_HZ        400
#define USER_TIMEBASE_OCCURENCE_TICKS  (SYS_TICK_FREQUENCY/USER_TIMEBASE_FREQUENCY_HZ)-1u  /*  CALC_TIME = USER_TIMEBASE_OCCURENCE_TICKS * 500usec (of systick) */
#define RESTART_DURATION  (STOP_DURATION_SEC * SYS_TICK_FREQUENCY/4)
#define TURNOFF_TIME_MAX_SEC (TURNOFF_TIME_SEC * SYS_TICK_FREQUENCY/4)
#define ARMING_TIME_DIGIT (ARMING_TIME_SEC * SYS_TICK_FREQUENCY/4)
#define SM_BEEP_1           0x01
#define SM_BEEP_2           0x02
#define SM_BEEP_3           0x03
#define SM_BEEP_4           0x04
#define USER_TIMEBASE_FREQUENCY_HZ_BEEP   400
#define USER_TIMEBASE_OCCURENCE_TICKS_BEEP  (SYS_TICK_FREQUENCY/USER_TIMEBASE_FREQUENCY_HZ_BEEP)-1u

uint32_t uwIC1Value = 0;     /* Captured Value */
uint32_t uwDutyCycle = 0;    /* Duty Cycle Value */
uint32_t uwTon_value = 0;    /* Ton Value */
uint32_t uwFrequency = 0;    /* Frequency Value */
uint32_t Ton_value_us = 0;   /* Ton Value in usec*/
uint8_t  PWM_fail_counter = 0;
uint8_t  PWM_fail_counter_prev = 0;
uint32_t PWM_TURNOFF_counter = 0;
uint32_t TURNOFF_TIME_counter = 0;
uint32_t PWM_TURNOFF_MAX  = 750;   

uint32_t ARMING_counter = 0; 
uint32_t PWM_tmp_buffer[FILTER_DEEP];                 /*!<  PWM filter variable */
uint32_t index_filter = 1;                            /*!<  PWM filter variable */
uint32_t PWM_filtered = 0;                            /*!<  PWM filter variable */
uint32_t PWM_sum_filt = 0;                            /*!<  PWM filter variable */
uint32_t Ton_max =  0;                                
uint32_t Ton_min =  0;                               
uint32_t delta_Ton_max = 0;  
uint32_t new_speed = 0;
uint32_t Ton_value = 0;                               /*!<  Stores the last ton value after the digital filter */
uint32_t Ton_value_previous = 0;
uint32_t Threshold_start_digit = 0;
uint32_t Threshold_stop_digit = 0;
uint32_t Ton_value_max_arming = 0; 
uint32_t backup_ARR = 0;
uint32_t BEEP_FREQ_ARR = 65000;
uint32_t BEEP_FREQ_ARR1 = 62000;
uint32_t BEEP_FREQ_ARR2 = 55000;
uint16_t User_BEEP_num = 1;
uint16_t BEEP_STOP_TIME = 0;
uint32_t backup_CCR = 0;
uint32_t BEEP_time_counter = 0;
uint32_t BEEP_TIME_MAX = 100; 
uint32_t BEEP_TIME_MAX_CHECK = 100;
uint32_t BEEP_DUTY = 1000;
uint32_t BEEP_PHASE_TIME = USER_TIMEBASE_OCCURENCE_TICKS_BEEP;
uint16_t new_speed_stored;

bool PWM_available = false;                        /*!< Used to avoid ARMING not requested in noisy application */
bool return_cmd = false;
static uint8_t User_BEEP_status = SM_BEEP_1;  
bool ESC_start_check_flag = false;
bool cmd_status = false;
static uint16_t UserCnt = 0;
float digit_to_usec = 3.12500023;
bool buffer_completed = false;                        /*!<  PWM filter variable */
extern bool UI_IdleTimeHasElapsed(void);
extern void UI_SetIdleTime(uint16_t);
extern TIM_HandleTypeDef htim1;
TIM_HandleTypeDef htim2;
User_State_t  User_State = SM_ARMING;              /*!< Variable containing state machine current */
ESC_State_t ESC_Fault_Occured = ESC_NOERROR;
static uint32_t counter_delay = 0;
/******************************************************************************/
 
void Init_PWM_Channel()
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_SlaveConfigTypeDef sSlaveConfig = {0};
  TIM_IC_InitTypeDef sConfigIC = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

    /* Peripheral clock enable */
  __HAL_RCC_TIM2_CLK_ENABLE();
 
  __HAL_RCC_GPIOA_CLK_ENABLE();

  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 22;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 65535;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_IC_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sSlaveConfig.SlaveMode = TIM_SLAVEMODE_RESET;
  sSlaveConfig.InputTrigger = TIM_TS_TI1FP1;
  sSlaveConfig.TriggerPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
  sSlaveConfig.TriggerPrescaler = TIM_ICPSC_DIV1;
  sSlaveConfig.TriggerFilter = 0;
  if (HAL_TIM_SlaveConfigSynchronization(&htim2, &sSlaveConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
  sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
  sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
  sConfigIC.ICFilter = 0;
  if (HAL_TIM_IC_ConfigChannel(&htim2, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_FALLING;
  sConfigIC.ICSelection = TIM_ICSELECTION_INDIRECTTI;
  if (HAL_TIM_IC_ConfigChannel(&htim2, &sConfigIC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }

  GPIO_InitStruct.Pin = GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /* TIM2 interrupt Init */
  HAL_NVIC_SetPriority(TIM2_IRQn, 3, 0);
  HAL_NVIC_EnableIRQ(TIM2_IRQn);
 
}


/**
  * @brief  Boot function to initialize the ESC board.
  * @retval none.
  */
void ESCboot(void)
{        
  
  Init_PWM_Channel();
  
    /* Enable the CC1 Interrupt Request */
  if (HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1) != HAL_OK)
  {
    /* Starting Error */
   Error_Handler();
  }

  /*##-5- Start the Input Capture in interrupt mode ##########################*/
  if (HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_2) != HAL_OK)
  {
    /* Starting Error */
    Error_Handler();
  }
  
  /***************************** for deug only *******************/
  GPIO_InitTypeDef GPIO_InitStruct;  
  GPIO_InitStruct.Pin = GPIO_PIN_4;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  
  Ton_max = (uint32_t)(float)(Ton_max_us * digit_to_usec);
  Ton_min = (uint32_t)(float)(Ton_min_us * digit_to_usec);
  Threshold_start_digit = (uint32_t)(float)(Threshold_start_us * digit_to_usec);
  Threshold_stop_digit  = (uint32_t)(float)(Threshold_stop_us * digit_to_usec);
  delta_Ton_max = (uint32_t)(Ton_max - Ton_min);   

    while(counter_delay <2000000)
    { 
    counter_delay ++;
    if(MC_GetSTMStateMotor1() == FAULT_OVER)
     {
      while(!MC_AcknowledgeFaultMotor1());
     }
    }
#ifdef TELEMETRY_LOG
    Telemetry_init_message();
#endif
}


/**
  * @brief  Input Capture callback in non blocking mode 
  * @param  htim : TIM IC handle
  * @retval None
  */
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
  
  PWM_fail_counter++;
  if(PWM_fail_counter == 0) 
     PWM_fail_counter = 1;
  
  if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
  {
    /* Get the Input Capture value - PWM period */
    uwIC1Value = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
    if (uwIC1Value != 0)
    {
      /* Duty cycle computation */
      uwDutyCycle = (uint32_t)((((float)HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2)) * 100.0f) / (float)uwIC1Value);
      uwDutyCycle += 1;
      
      uwTon_value = (uint32_t)HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2);
        
      Ton_value = TIMCapture_filter(uwTon_value);
      
      PWM_available = true;
  
      Ton_value_us = (uint32_t)(float)(1/digit_to_usec * Ton_value);

      /* uwFrequency computation
      TIM2 counter clock = (RCC_Clocks.HCLK_Frequency) */
      uwFrequency = (HAL_RCC_GetHCLKFreq())  / (uwIC1Value*(htim->Init.Prescaler+1));
    }
    else
    {
      uwDutyCycle = 0;
      uwFrequency = 0;
    }  
   }
}

/**
  * @brief This function handles TIM2 global interrupt.
  */
void TIM2_IRQHandler(void)
{
  /* USER CODE BEGIN TIM2_IRQn 0 */

  /* USER CODE END TIM2_IRQn 0 */
  HAL_TIM_IRQHandler(&htim2);
  /* USER CODE BEGIN TIM2_IRQn 1 */

  /* USER CODE END TIM2_IRQn 1 */
}

void ESC_reset_PWM_CH()
{
    uint16_t tmpccer = 0; 
    HAL_TIM_PWM_Stop(&htim1,TIM_CHANNEL_1);
    HAL_TIM_PWM_Stop(&htim1,TIM_CHANNEL_2);    
    HAL_TIM_PWM_Stop(&htim1,TIM_CHANNEL_3); 
    htim1.Instance->BDTR &= (uint16_t)~TIM_BDTR_MOE;
    htim1.Instance->ARR = backup_ARR;
    htim1.Instance->CCR1 = backup_CCR;
    htim1.Instance->CCR2 = backup_CCR;        
    htim1.Instance->CCR3 = backup_CCR;     
    tmpccer = htim1.Instance->CCER; 
    /* Set the Output State */ 
    tmpccer |= (uint32_t)TIM_CCER_CC1E;
    tmpccer |= (uint32_t)TIM_CCER_CC2E;   
    tmpccer |= (uint32_t)TIM_CCER_CC3E; 
    tmpccer |= (uint32_t)TIM_CCER_CC1NE;
    tmpccer |= (uint32_t)TIM_CCER_CC2NE;   
    tmpccer |= (uint32_t)TIM_CCER_CC3NE;   
    htim1.Instance->CCER = tmpccer; 
}

bool ESC_Beep_loop(uint16_t number_beep)
{ 
   uint16_t tmpccer = 0;
   bool ESC_Beep_loop_STATUS = false;
        
 /* TIMx Peripheral Configuration -------------------------------------------*/     
  if(ESC_start_check_flag == false)
  {
     ESC_start_check_flag = true;
     tmpccer = htim1.Instance->CCER;
    
     ESC_Beep_loop_STATUS = false;
   
    /* Set the Output State */
    backup_ARR = htim1.Instance->ARR;
    backup_CCR = htim1.Instance->CCR3;
    htim1.Instance->ARR = BEEP_FREQ_ARR;    
    tmpccer &= (uint32_t)~TIM_CCER_CC1E;
    tmpccer &= (uint32_t)~TIM_CCER_CC2E;   
    tmpccer &= (uint32_t)~TIM_CCER_CC3E; 
    tmpccer &= (uint32_t)~TIM_CCER_CC1NE;
    tmpccer &= (uint32_t)~TIM_CCER_CC2NE;   
    tmpccer &= (uint32_t)~TIM_CCER_CC3NE;   
    htim1.Instance->CCER = tmpccer;
    
    HAL_TIM_PWM_Start(&htim1,TIM_CHANNEL_1);
    HAL_TIM_PWM_Start(&htim1,TIM_CHANNEL_2);    
    HAL_TIM_PWM_Start(&htim1,TIM_CHANNEL_3);      
  }  
 if(UI_IdleTimeHasElapsed())
 { 
  /* User defined code */
  switch (User_BEEP_status)
  {
   case SM_BEEP_1:
    { 
      if(BEEP_time_counter == 0)
      {
        tmpccer = htim1.Instance->CCER;
        htim1.Instance->CCR1 = BEEP_DUTY;  
        htim1.Instance->CCR2 = BEEP_FREQ_ARR;        
        tmpccer &= (uint32_t)~TIM_CCER_CC3E;
        htim1.Instance->CCER = tmpccer;         
        tmpccer &= (uint32_t)~TIM_CCER_CC2E;  
        htim1.Instance->CCER = tmpccer;         
        tmpccer &= (uint32_t)~TIM_CCER_CC3NE;
        htim1.Instance->CCER = tmpccer;           
        tmpccer |= (uint32_t)TIM_CCER_CC2NE; 
        htim1.Instance->CCER = tmpccer;           
        tmpccer |= (uint32_t)TIM_CCER_CC1E; 
        htim1.Instance->CCER = tmpccer;         
        tmpccer |= (uint32_t)TIM_CCER_CC1NE;            
        htim1.Instance->CCER = tmpccer;        
      }
      BEEP_time_counter++;
      
      if(BEEP_time_counter > BEEP_TIME_MAX)
      {
        if(number_beep == 1)
        {
          BEEP_STOP_TIME = 570;
          User_BEEP_status =  SM_BEEP_4; 
        }
        if(number_beep == 2)
        {
          User_BEEP_num ++;
          if(User_BEEP_num <= 2)
          {
          htim1.Instance->CCR1 = 0; 
          User_BEEP_status =  SM_BEEP_3; 
          }
          else 
          {
            BEEP_STOP_TIME = 410;
            User_BEEP_status = SM_BEEP_4;
            User_BEEP_num = 1;
          }
        } 
        if(number_beep == 3)
        {
          User_BEEP_num ++;
          if(User_BEEP_num <= 3)
          {
         htim1.Instance->CCR1 = 0; 
          User_BEEP_status =  SM_BEEP_3; 
          }
          else 
          {
            BEEP_STOP_TIME = 270;
            User_BEEP_status = SM_BEEP_4;
            User_BEEP_num = 1;
          }
        }         
       BEEP_time_counter = 0;
      }
    }
   break; 
  case SM_BEEP_3:
    {
    if(BEEP_time_counter == 0)
      {
         htim1.Instance->CCR1 = 0;      
      }
      BEEP_time_counter++;
      
      if(BEEP_time_counter > 50)
      {
        User_BEEP_status =  SM_BEEP_1; 
        BEEP_time_counter = 0;
      }
    }
   break;      
   case SM_BEEP_4:
    {
    if(BEEP_time_counter == 0)
      {
      htim1.Instance->CCR1 = 0;       
      htim1.Instance->CCR2 = 0;  
      htim1.Instance->CCR3 = 0;  
      }
      BEEP_time_counter++;
      
      if(BEEP_time_counter > BEEP_STOP_TIME)
      {
        User_BEEP_status =  SM_BEEP_1; 
        BEEP_time_counter = 0;
        ESC_reset_PWM_CH();
        ESC_start_check_flag = false;
        ESC_Beep_loop_STATUS = true;
      }
    }
   break;   
  }
 UI_SetIdleTime(BEEP_PHASE_TIME);
 }
 return (ESC_Beep_loop_STATUS);
}

/*This is the main function to use in the main.c in order to start the current example */
void pwm_start()
{ 
 if(UI_IdleTimeHasElapsed())
 { 
//  HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_4);   
  /* User defined code */
  switch (User_State)
  { 
   case SM_ARMING:
    {
      Ton_value_previous = 0;
      Ton_value_max_arming = (uint32_t) (Ton_min + (float)((Ton_max - Ton_min)>>1));
      
      if((Ton_value > (Ton_min + Threshold_start_digit) && Ton_value < Ton_value_max_arming))
      {
        ARMING_counter++;
        if(ARMING_counter > ARMING_TIME_DIGIT && PWM_available == true)    
         { 
           User_State = SM_ARMED;   
           ARMING_counter  = 0;
           PWM_TURNOFF_counter = 0;                   
           PWM_fail_counter = 0;
           PWM_fail_counter_prev = 0;   
           buffer_completed = false;
         }
         PWM_available = false;
      }
      else 
       {
         PWM_available = false;
         User_State = SM_ARMING;          
         ARMING_counter  = 0;
       }
 /****************************** INPUT SIGNAL LOSS ***************BEGIN********/
#ifdef PWM_ESC    
   if(PWM_fail_counter == PWM_fail_counter_prev)
       {
         PWM_TURNOFF_counter++;
 
         if(PWM_TURNOFF_counter > PWM_TURNOFF_MAX)
         {
          ESC_Beep_loop(1);
          Ton_value_previous = 0;
         }
       }
       else 
       {
         PWM_TURNOFF_counter = 0;
         ESC_reset_PWM_CH();
       }      
    PWM_fail_counter_prev = PWM_fail_counter; 
#endif
 /****************************** INPUT SIGNAL LOSS ****************END********/        
      }
    break;  
   case SM_ARMED:
    {
          /* Next state */
          /* This command sets what will be the first speed ramp after the 
          MCI_StartMotor command. It requires as first parameter the oMCI[0], as 
          second parameter the target mechanical speed in thenth of Hz and as
          third parameter the speed ramp duration in milliseconds. */

          MC_ProgramSpeedRampMotor1(speed_min_valueRPM/6, 0);
          /* This is a user command used to start the motor. The speed ramp shall be
          pre programmed before the command.*/

          cmd_status = MC_StartMotor1();          
          
          /* It verifies if the command  "MCI_StartMotor" is successfully executed 
          otherwise it tries to restart the procedure */
          if(cmd_status==false)    
           {
            User_State = SM_ARMING;                       // Command NOT executed
           }
          else User_State = SM_POSITIVE_RUN;              // Command executed
 
          UserCnt = 0;
    }
    break;  
   case SM_POSITIVE_RUN:
    {  
       if(PWM_fail_counter == PWM_fail_counter_prev)
       {
         PWM_TURNOFF_counter++;
 
         if(PWM_TURNOFF_counter > PWM_TURNOFF_MAX)
         {
          User_State = SM_STOP; 
          Ton_value_previous = 0;
          ESC_Fault_Occured = ESC_NOSIGNAL;
         }
       }
       else 
       {
         PWM_TURNOFF_counter = 0;
       }

       if(Ton_value > 0 && Ton_value < (Ton_min - Threshold_stop_digit))
       {
//         HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4,GPIO_PIN_SET); 
         TURNOFF_TIME_counter ++;
         if(TURNOFF_TIME_counter > TURNOFF_TIME_MAX_SEC)
         {
          User_State = SM_STOP; 
          Ton_value_previous = 0;          
          TURNOFF_TIME_counter = 0;
          ESC_Fault_Occured = ESC_PWM_BELOW_MIN;
//          HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4,GPIO_PIN_RESET);   
         }         
       }
       else 
       {
         TURNOFF_TIME_counter = 0;
       }
                        
       if(Ton_value<= Ton_max && Ton_value > Ton_min)
       {
          new_speed = (uint32_t)((float) speed_min_valueRPM + (float)(speed_max_valueRPM - speed_min_valueRPM)*((float)(Ton_value-Ton_min) / (float)delta_Ton_max));   
       }
       else if(Ton_value>Ton_max)
       {
         new_speed = speed_max_valueRPM;
       }
                  
       if(new_speed <  speed_min_valueRPM)
        new_speed =  speed_min_valueRPM;
       if(new_speed > speed_max_valueRPM)
        new_speed = speed_max_valueRPM;        
  
#ifdef TELEMETRY_LOG       
    new_speed_stored = new_speed;       /* for Telemetry */
#endif    
   
    if(MC_GetSTMStateMotor1()== RUN)       
     {
       MC_ProgramSpeedRampMotor1(new_speed/6, 0); 
     }
     
       PWM_fail_counter_prev = PWM_fail_counter;
    }
    break;
   case SM_STOP:
    {
       /* This is a user command to stop the motor */
       MC_StopMotor1();
        
       /* After the time "RESTART_DURATION" the motor will be restarted */
       if (UserCnt >= RESTART_DURATION)
          {
            /* Next state */ 
            User_State = SM_ARMING;   
            UserCnt = 0;   
            Ton_value  = 0;
            ARMING_counter = 0;
            Ton_value_previous = 0;
            new_speed_stored = 0;           
            buffer_completed = false;            
          }
          else
          {
            UserCnt++;
          }
    }
    break;  
  }
  UI_SetIdleTime(USER_TIMEBASE_OCCURENCE_TICKS);
 }
}


uint32_t TIMCapture_filter(uint32_t capture_value)
{ 
  if(buffer_completed == false)
  {
     PWM_tmp_buffer[index_filter] = capture_value;    
     PWM_sum_filt = 0;
     for(uint32_t i = 1; i <= index_filter;i++)
     {
       PWM_sum_filt = PWM_sum_filt + PWM_tmp_buffer[i];
     }
     PWM_filtered = PWM_sum_filt/index_filter;
     index_filter++;
     
      if(index_filter >= FILTER_DEEP) 
       {
         index_filter = 1;
         buffer_completed = true;
       }
  }  
  else
  {
     index_filter++;
     if(index_filter >= FILTER_DEEP)
     {
      index_filter = 1;
     }
     
     PWM_sum_filt = 0;
     PWM_tmp_buffer[index_filter] = capture_value;
     uint32_t PWM_max = 0;
     for(uint32_t i = 1; i < FILTER_DEEP;i++)
     {
       uint32_t val = PWM_tmp_buffer[i];
       if (val > PWM_max)
       {
         PWM_max = val;
       }
       PWM_sum_filt = (uint32_t) (PWM_sum_filt +val);
     }
     PWM_sum_filt -= PWM_max;
     PWM_filtered = PWM_sum_filt/(FILTER_DEEP-2);
  }
  if(PWM_filtered==0) PWM_filtered = 1;
  
return(PWM_filtered);
}



bool ESC_phase_check()
{ 
   uint16_t tmpccer = 0;
   bool ESC_phase_check_status = false;
 
 /* TIMx Peripheral Configuration -------------------------------------------*/    
  if(ESC_start_check_flag == false)
  {
    ESC_start_check_flag = true;
    tmpccer = htim1.Instance->CCER;
    /* Set the Output State */
    ESC_phase_check_status = false;
    backup_ARR = htim1.Instance->ARR;
    backup_CCR = htim1.Instance->CCR3;
    htim1.Instance->ARR = BEEP_FREQ_ARR;       
    tmpccer &= (uint32_t)~TIM_CCER_CC1E;
    tmpccer &= (uint32_t)~TIM_CCER_CC2E;   
    tmpccer &= (uint32_t)~TIM_CCER_CC3E; 
    tmpccer &= (uint32_t)~TIM_CCER_CC1NE;
    tmpccer &= (uint32_t)~TIM_CCER_CC2NE;   
    tmpccer &= (uint32_t)~TIM_CCER_CC3NE;   
    htim1.Instance->CCER = tmpccer;
  
    HAL_TIM_PWM_Start(&htim1,TIM_CHANNEL_1);
    HAL_TIM_PWM_Start(&htim1,TIM_CHANNEL_2);    
    HAL_TIM_PWM_Start(&htim1,TIM_CHANNEL_3);     
                   

  }  
 if(UI_IdleTimeHasElapsed())
 { 
   HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_4);     
  /* User defined code */
  switch (User_BEEP_status)
  {
   case SM_BEEP_1:
    { 
      if(BEEP_time_counter == 0)
      {
//        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4,GPIO_PIN_SET); 
        tmpccer = htim1.Instance->CCER;
        htim1.Instance->CCR3 = BEEP_DUTY;          
        tmpccer &=  (uint32_t)~TIM_CCER_CC1E;
        tmpccer |= (uint32_t)TIM_CCER_CC1NE;        
        tmpccer &= (uint32_t)~TIM_CCER_CC2E;          
        tmpccer |= (uint32_t)TIM_CCER_CC2NE;  /* Low side signal on CH2 */
        tmpccer |= (uint32_t)TIM_CCER_CC3E;   /* PWM signal on CH3      */
        tmpccer |= (uint32_t)TIM_CCER_CC3NE;  /* PWM signal on CH3      */      
        htim1.Instance->CCR2 = BEEP_FREQ_ARR;
        htim1.Instance->CCR1 = BEEP_FREQ_ARR;        
        htim1.Instance->CCER = tmpccer;        
      }
      BEEP_time_counter++;
      if(BEEP_time_counter > BEEP_TIME_MAX_CHECK)
      {
        User_BEEP_status =  SM_BEEP_2; 
        BEEP_time_counter = 0;
        htim1.Instance->CCR2 = BEEP_DUTY;   
        htim1.Instance->ARR = BEEP_FREQ_ARR1;  
      }
    }
   break; 
   case SM_BEEP_2:
    {
    if(BEEP_time_counter == 0)
      {
//        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4,GPIO_PIN_RESET); 
        tmpccer = htim1.Instance->CCER;
        htim1.Instance->CCR2 = BEEP_DUTY;                  
        tmpccer &=  (uint32_t)~TIM_CCER_CC3E;  
        tmpccer |=  (uint32_t)TIM_CCER_CC3NE;
        tmpccer &= (uint32_t)~TIM_CCER_CC1E;        
        tmpccer |= (uint32_t)TIM_CCER_CC1NE;      /* Low side signal on CH1 */
        tmpccer |= (uint32_t)TIM_CCER_CC2E;       /* PWM signal on CH2      */
        tmpccer |= (uint32_t)TIM_CCER_CC2NE;      /* PWM signal on CH2      */        
        htim1.Instance->CCR1 = BEEP_FREQ_ARR;     
        htim1.Instance->CCR3 = BEEP_FREQ_ARR;           
        htim1.Instance->CCER = tmpccer;           
      }
      BEEP_time_counter++;
      
      if(BEEP_time_counter > BEEP_TIME_MAX_CHECK)
      {
        User_BEEP_status =  SM_BEEP_3; 
        BEEP_time_counter = 0;
        htim1.Instance->CCR1 = BEEP_DUTY;  
        htim1.Instance->ARR = BEEP_FREQ_ARR2;          
      }
    }
   break;  
   case SM_BEEP_3:
    {
    if(BEEP_time_counter == 0)
      {
//        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4,GPIO_PIN_SET); 
        tmpccer = htim1.Instance->CCER;
        htim1.Instance->CCR1 = BEEP_DUTY;           
        tmpccer &= (uint32_t)~TIM_CCER_CC2E;  
        tmpccer |= (uint32_t)TIM_CCER_CC2NE;
        tmpccer &= (uint32_t)~TIM_CCER_CC3E;        
        tmpccer |= (uint32_t)TIM_CCER_CC3NE;      /* Low side signal on CH3 */
        tmpccer |= (uint32_t)TIM_CCER_CC1E;       /* PWM signal on CH1      */
        tmpccer |= (uint32_t)TIM_CCER_CC1NE;      /* PWM signal on CH1      */       
        htim1.Instance->CCR2 = BEEP_FREQ_ARR;
        htim1.Instance->CCR3 = BEEP_FREQ_ARR;
        htim1.Instance->CCER = tmpccer;   
        
      }
      BEEP_time_counter++;
      
      if(BEEP_time_counter > BEEP_TIME_MAX_CHECK)
      {
        User_BEEP_status =  SM_BEEP_4; 
        BEEP_time_counter = 0;
      }    
    }
   break;  
   case SM_BEEP_4:
    {
//    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4,GPIO_PIN_RESET); 
    if(BEEP_time_counter == 0)
      {
      htim1.Instance->CCR1 = 0;  
      htim1.Instance->CCR2 = 0; 
      htim1.Instance->CCR3 = 0; 
      }
      BEEP_time_counter++;
      
      if(BEEP_time_counter > 1000)
      {
        User_BEEP_status =  SM_BEEP_1; 
        BEEP_time_counter = 0; 
        ESC_reset_PWM_CH();
        ESC_start_check_flag = false;
        ESC_phase_check_status = true;       
      }
    }
   break;    
  }
 UI_SetIdleTime(BEEP_PHASE_TIME);
 }
 return(ESC_phase_check_status);
}

/**
  * @brief  This function handles PWM control from input signal
  * @param  None
  * @retval None
  */
void PWM_FC_control()
{
#ifdef PWM_ESC      
 if(return_cmd != true)
 {
  return_cmd = ESC_phase_check();
 }
 else
 {   
   pwm_start();
 }
 
 if(MC_GetSTMStateMotor1() == FAULT_OVER)
 {
  while(!MC_AcknowledgeFaultMotor1());
  User_State = SM_STOP;   
  ARMING_counter  = 0;
 }
#endif
 
#ifdef TELEMETRY_LOG
       Telemetry_DataLog();
#endif 
}





/******************* (C) COPYRIGHT 2016 STMicroelectronics *****END OF FILE****/
